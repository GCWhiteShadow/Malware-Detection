import tensorflow as tf
from math import floor


class Classifier:
    def __init__(self, data, features, shape, hiddens, n_class):
        self.data = data
        self.features = features
        self.shape = shape
        self.hiddens = hiddens
        self.n_class = n_class
        self.weight = []
        self.bias = []
        self.file = open('log', 'w')

    def train(self, step=500):
        data = tf.constant(self.data, shape=[len(self.data), len(self.data[0])])

        i0 = tf.truncated_normal_initializer(stddev=0.1)
        w0 = tf.get_variable('w0_fc', [self.shape, self.hiddens[0]], initializer=i0)
        b0 = tf.get_variable('b0_fc', [self.hiddens[0]], initializer=tf.zeros_initializer())
        h0 = tf.nn.relu(tf.matmul(tf.cast(data, tf.float32), w0) + b0)
        drop = tf.nn.dropout(h0, 0.5)
        i1 = tf.truncated_normal_initializer(stddev=0.1)
        w1 = tf.get_variable('w1_fc', [self.hiddens[0], self.hiddens[1]], initializer=i1)
        b1 = tf.get_variable('b1_fc', [self.hiddens[1]], initializer=tf.zeros_initializer())
        predict = tf.matmul(drop, w1) + b1

        # cross_entropy = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(logits=predict, labels=self.features))
        cost = tf.reduce_mean(tf.pow(predict - self.features, 2))
        train_op = tf.train.AdamOptimizer().minimize(cost)

        with tf.Session() as sess:
            sess.run(tf.global_variables_initializer())
            for i in range(step):
                sess.run(train_op)
                if (i + 1) % 10 == 0:
                    self.weight = [w0, w1]
                    self.bias = [b0, b1]
                    print('step: %i, accuracy: %f' % ((i+1), self.accuracy(sess)))
                if i == step - 1:
                    print(sess.run(predict))

    def accuracy(self, sess):
        test = tf.constant(self.data)
        h0 = tf.matmul(tf.cast(test, tf.float32), self.weight[0]) + self.bias[0]
        predict = tf.matmul(h0, self.weight[1]) + self.bias[1]

        predict = sess.run(predict)

        count = 0
        l = len(self.data)
        for i in range(l):
            if self.features[i] == floor(predict[i] + 0.5):
                count = count + 1
        return count / l
